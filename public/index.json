[{"body":" 重点  云原生已渡过了野蛮生长期，正朝着统一应用标准方向迈进。 Kubernetes 的原语无法完整描述云原生应用体系，且在对资源的配置上开发与运维功能耦合严重。 Operator 在扩展了 Kubernetes 生态的同时导致云原生应用碎片化，亟需一个统一的应用定义标准。 OAM 的本质是将云原生应用的定义中的研发、运维关注点分离，资源对象进行进一步抽象，化繁为简，高罗万象。 “Kubernetes 次世代”是指在 Kubernetes 成为基础设施层标准之后，云原生生态的关注点正在向应用层过度，近两年来火热的 Service Mesh 正式该过程中的一次有力探索，而基于 Kubernetes 之上的云原生应用架构的时代即将到来。  Kubernetes 已成为云原生应用的既定运行平台，本文以 Kubernetes 为默认平台展开，包括云原生应用的分层模型。\n云原生的不同发展阶段 Kubernetes 从开源至今已经走过快六个年头（2014 年 6 月开源）了，可以说是 Kubernetes 的诞生开启了整个云原生的时代。我粗略的将云原生的发展划分为以下几个时期。\n第一阶段：孵化期（2014 年）\n2014 年，Google 开源 Kubernetes，在此之前的 2013 年，Docker 开源，DevOps、微服务已变得十分流行，云原生的概念已经初出茅庐。在开源了 Kubernetes 之后，Google 联合其他厂商发起成立了 CNCF，并将 Kubernetes 作为初创项目捐献给了 CNCF。CNCF 作为云原生的背后推手，开始推广 Kubernetes。\n第二阶段：高速发展期（2015 年 - 2016 年）\n这几年间，Kubernetes 保持着高速发展，并于 2017 年打败了 Docker Swarm、Mesos，确立了容器编排工具领导者的地位。CRD 和 Operator 模式的诞生，大大增强了 Kubernetes 的扩展性，促进了周边生态的繁荣。\n第三阶段：野蛮生长期（2017 年 - 2018 年）\n2106 年之后的云原生基本都默认运行在 Kubernetes 平台上，2017、2018 年 Google 主导的 Istio、Knative 相继开源，这些开源项目都大量利用了 Kubernetes 的 Operator 进行了扩展，Istio 刚发布时就有 50 多个 CRD 定义。Istio 号称是后 Kubernetes 时代的微服务，它的出现第一次使得云原生以服务（应用）为中心。Knative 是 Google 在基于 Kubernetes 之上开源的 Serverless 领域的一次尝试。2018 年 Kubernetes 正式从 CNCF 毕业，Prometheus、Envoy 也陆续从 CNCF 毕业。CNCF 也与 2018 年修改了 charter，对云原生进行了重定义，从原来的三要素：”应用容器化；面向微服务架构；应用支持容器的编排调度“，修改为”云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API“。这一年，我曾写过两篇 Kubernetes 及云原生发展的年终总结和展望，见 2017 年和 2018 年的预测和总结。\n第四阶段：普及推广期（2019 年至今）\n经过几年的发展，Kubernetes 已经得到的大规模的应用，云原生的概念开始深入人心，Kubernetes 号称是云原生的操作系统，基于 Operator 模式的生态大放异彩。整合 Kubernetes 和云基础设施，研发和运维关注点分离。Kubernetes 到 Service Mesh（后 Kubernetes 时代的微服务），基于 Kubernetes 的 Serverless 都在快速发展，OAM 诞生，旨在定义云原生应用标准。\nKubernetes 开辟了云原生时代 Kubernetes 开源之初就继承了 Google 内部调度系统 Borg 的经验，屏蔽掉了底层物理机、虚拟机之间的差异，经过几年时间的发展成为了容器编排标准，进而统一了 PaaS 平台的基础设施层。\n下图是Kubernetes 原生内置的可以应用到一个 Pod 上的所有控制器、资源对象等。\n图片来自图书 Kubernetes Patterns（O’Reilly）\nKubernetes 作为云原生基础设施设计之初遵循了以下原则：\n 基础设施即代码（声明式 API） 不可变基础设施 幂等性 调节器模式（Operator 的原理）  其中声明式 API 可谓开创了云原生时代的基调，而调节器模式是 Kubernetes 区别于其他云部署形式的主要区别之一，这也为后来的 Operator 框架的诞生打下了基础。\n声明式 API 根据声明式 API 可以做应用编排，定义组件间的依赖，通常使用人类易读的 YAML 文件来表示。但是，YAML 文件声明的字段真的就是最终的状态吗？有没有可能动态改变？\n我们在创建 Deployment 时会指定 Pod 的副本数，但是其实际副本数并不一定是一成不变的。假如集群中还有定义 HPA，那么 Pod 的副本数就可能随着一些外界因素（比如内存、CPU 使用率或者自定义 metric）而改变，而且如果集群中还有运行自定义的控制器话，那么也有可能修改应用的实例数量。在有多个控制器同时控制某个资源对象时，如何确保控制器之间不会发生冲突，资源对象的状态可预期？\n一个办法是使用动态准入控制，\nKubernetes 原生应用 我们都知道要想运行一个应用至少需要以下几点：\n 应用的业务逻辑（代码）、运行时（可运行的二进制文件、字节码或脚本）。 应用的配置注入（配置文件、环境变量等），身份、路由、服务暴露等满足应用的安全性和可访问性。 应用的生命周期管理（各种 Controller 登场）。 可观察性、可运维、网络和资源及环境依赖、隔离性等。  下图展示了基于 Kubernetes 原语及 PaaS 平台资源的 Kubernetes 原生应用的组成。\n我们都知道 Kubernetes 提供了大量的原语，用户可以基于这些原语来编排服务，管理应用的生命周期。上图展示的是基于 Kubernetes 原生应用可以使用的 Kubernetes 原语、扩展及平台层资源，从内向外的对象跟应用程序（业务逻辑）的关联度依次降低，到最外层基本只剩下平台资源依赖，已经与 Kubernetes 几乎没有关系了。该图里仅展示了部分资源和对象（包含阿里巴巴开源的 OpenKruise、Istio），实际上 Operator 资源之丰富，也是 Kubernetes 生态如此繁荣的原因之一。\nKubernetes 本身的原语、资源对象、配置、常用的 CRD 扩展有几十、上百个之多。开发者需要了解这些复杂的概念吗？我只是想部署一个应用而已！不用所对于应用开发者，即使对于基础实施开发和运维人员也需要很陡峭的学习曲线才能完全掌握它。\n我将 Kubernetes 原生应用所需要的定义和资源进行了分层：\n 核心层：应用逻辑、服务定义、生命周期控制； 隔离与服务访问层：资源限制与隔离、配置、身份、路由规则等； 调度层：各种调度控制器，这也是 Kubernetes 原生应用的主要扩展层； 资源层：提供网络、存储和其他平台资源；  而这些不同的层，完全可以将其职责分配给相应的人员，比如核心层是由应用程序开发者负责，将其职责分离，可以很大程度上降低\n云原生应用落实到 Kubernetes 平台之上，仅仅利用 Kubernetes 的对象原语已很难描述一个复杂的应用程序，所以诞生了各种各样的 Operator，但这也仅仅解决了单个应用的定义，对于应用的打包封装则无能为力。\n同一个资源对象又有多种实现方式，比如 Ingress 就有 10 多种实现，PV 就更不用说，对于对于开发者究竟如何选择，平台如何管理，这都是让人很头疼的问题。而且有时候平台所提供的扩展能力还可能会有冲突，这些能力有的可能互不相干，有的可能会有正交，有的可能完全重合。且应用本身与运维特性之间存在太多耦合，不便于复用。\n上图中不同颜色的方框代表不同的资源类别，红线框代表不能为一个资源同时应用该配置，否则会出现冲突，不同的颜色上面是一个动画，展示的是部分资源组合。图中仅包含了部分 Kubernetes 中的原语和 Istio 中的资源对象组合及自定义扩展，实际上用户可以根据应用的自身特点，基于 Kubernetes 原语和 CRD 创建出千变万化的组合。\n为了管理这些应用诞生出了众多的 Operator。Kubernetes 1.7 版本以来就引入了自定义控制器的概念，该功能可以让开发人员扩展添加新功能，更新现有的功能，并且可以自动执行一些管理任务，这些自定义的控制器就像 Kubernetes 原生的组件一样，Operator 直接使用 Kubernetes API进行开发，也就是说它们可以根据这些控制器内部编写的自定义规则来监控集群、更改 Pods/Services、对正在运行的应用进行扩缩容。\nOperator 的本质是一种调节器模式（Reconciler Pattern）的应用，跟 Kubernetes 本身的实现模式是一样的，用于管理云原生应用，协调应用的实际状态达到预期状态。\n调节器模式的四个原则：\n 所有的输入和输出都使用数据结构。 确保数据结构是不可变的。 保持资源映射简单。 使实际状态符合预期状态。  云原生应用走向碎片化 利用声明式 API 及调节器模式，理论上可以在 Kubernetes 上部署任何可声明应用，但是在 Operator 出现之前，管理 Kubernetes 上的有状态应用一直是一个难题，随着 Operator 模式的确立，该难题已得以解决，并促进了 Kubernetes 生态的进一步发展。随着该生态的繁荣，有一种碎片化的特征正在显现。\n云原生应用碎片化的体现  Operator 模式将运维人员的反应式经验转化成基于 Reconcile 模式的代码，统一了有状态应用的管理模式，极大得扩展了 Kubernetes 应用生态。 开发者在引用 Operator 所提供的能力时没有统一的视图，加大了基础设施运维与开发者之间的沟通成本。 Operator 总体上治理松散，没有统一的管控机制，在同时应用时可能导致互相冲突或无法预期的结果发生。   有状态应用管理难题 Kubernetes 对于无状态应用的管理很出色，但是对于有状态应用就不是那么回事了。虽然 StatefulSet 可以帮助管理有状态应用，但是这还远远不够，有状态应用往往有复杂的依赖。声明式的 API 里往往要加载着大量的配置和启动脚本，才能实现一个复杂应用的 Kubernetes 化。\n例如在 2017 年初，Operator Framework 出现之前，需要使用大量的 ConfigMap、复杂的启动脚本才能在 Kubernetes 上定义 Hadoop YARN 和运行 Spark。虽然 StatefulSet 号称可以解决有状态应用的部署问题，但是它主要是保证了 Pod 的在启动、伸缩时的顺序和使 Pod 具有稳定的标识。但是很多分布式应用来说并不仅依靠启动顺序就可以保证其状态，根据其在分布式应用中的角色不同（master/worker）而需要有大量的自定义配置，在没有 Operator 之前这些配置通常是通过一些自定义脚本来实现，这些脚本可能存在于应用镜像中，也可以通过 ConfigMap 挂在到容器运行时，但无论如何这些脚本都可能因为散落在各处，这些脚本还是面向过程的，跟在 Kubernetes 诞生之前的运维方式毫无二致，这极其不便于版本控制和运维管理。\nOperator 统一了 Kubernetes 应用运维框架 Operator 大大增强了 Kubernetes 的可扩展性，丰富了以 Kubernetes 为基础的云原生生态，许多原先不是为 Kubernetes 而构建的应用纷纷通过构建自己的 Operator 迁移到 Kubernetes 上。还有一些直接基于 Kubernetes 构建的 Service Mesh、Serverless 框架，它们应用 Operator 模式（如 Istio、Knative），试图成为云原生应用的基础设施层，补齐 Kubernetes 在服务治理、无服务架构等方面的短板，随着大量的 CRD、Operator 控制器的出现，而 Kubernetes 却无法以应用的视角来管理这些能力及其背后零散的 CRD，这使得云原生应用碎片化。\nOperator 百花齐放，在没有一个大一统的视图之前，各个控制器之间存在着这样的关系：\n 独立：互不干涉，比如 Controller 与服务发现之间就不存在冲突。 可组合：例如 Service、VirtualService、DestinationRule 同属一类资源（可访问性与路由），就是可组合的（后两者是 Istio 中的 CRD，用于流量管理）。 有冲突：例如图中的 CronHorizontalPodAutoscaler（CRD）、HorizontalPodAutoscaler（Kubernetes 内置），同时使用可能导致无法意料的情况发生。  正是以为这样复杂的关系，导致其无法做到开箱即用，还需要基础设施团队基于云原生社区和生态自己构建出来的，比如应用交付领域的系列开源项目。\n云原生应用管理工具 Helm Kubernetes 之上有很多能力缺失，比如应用构建、发布、管理和运维等，Helm 的出现主要补偿了应用打包和版本管理的缺陷。其中云原生应用的配置包括：\n 应用程序启动时加载的配置文件； 应用程序的运维配置，如资源申请限额； 应用程序的服务发现配置； 应用程序的工作负载、发布策略、依赖等；  这些配置可以存在于 ConfigMap、Deployment、Service、Ingress 等 Kubernetes 的多个资源文件中，如何保证应用程序的复用性？应用程序之间有依赖该如何解决？这是时候你可能自然的想到了 Helm。\n云原生应用打包和发布管理  Helm 通过 chart 模板，提高了应用程序的复用性并解决了部分依赖问题； Chart 仓库提供了云原生应用程序的统一管控视图； Release 概念的引入，使得云原生应用版本化管理进一步加强；   Helm 主要关注的是 12 因素应用法则构建、发布、运行这一原则中的”发布”这一环节。下图是 Helm v3 的架构图。\nHelm 可以安装本地或者远程的 chart，当 chart 安装到 Kubernetes 中后就会创建一个 release，每次更新该 chart 的配置并执行 helm upgrade， release 的版本数就会加 1，开发者可以升级 chart 或回滚到历史版本。\n打包、配置和发布 Helm 和 chart 的主要作用是：\n 应用程序封装 版本管理 依赖检查 便于应用程序分发  打包\nHelm 采用 Chart 的格式来标准化描述应用，可以将目录打包成版本化的压缩包进行部署理论上一个 Chart 是可以嵌套若干个 Chart 并定义依赖关系，组织形式非常灵活。Helm chart 用于打包 Kubernetes 原生应用。\n配置\n应用配置参数，在 Chart 中由 values.yaml 和命令行参数组成。Chart 采用 Go Template 的特性和 values.yaml 对部署的模板文件进行参数渲染，也可以通过 helm 命令 --set key=value 的方式进行参数赋值。\n发布\nRelease 代表 Chart 在集群中的运行实例，Helm 围绕 Release 对应用提供了强大的生命周期管理能力，包括 Release 的查询、安装、更新、删除、回滚等。\n云原生应用 以上关注的点都是基于 Kubernetes 原语的实现，虽然基于 Kubernetes 构建的 PaaS 平台部分屏蔽了底层基础设施的差异，但是仍有很多云服务是无法通过 Kubernetes 创建，或者需要提前创建供 Kubernetes 原生应用使用的，这些应用通常不运行在 Kubernetes 集群中。因此创建和管理一个云原生应用程序需要考虑以下方面：\n 运行时：ECS、Docker、KataContainer、gVisor 等； 资源隔离性：多租户、VPC、Namespace、防火墙； 资源调度：各种类型的 controller； 网络可达性：Service、Ingress、Egress、Gateway、VirtualService、DestinationRule、LoadBalancer、ServiceEntry 等； 可观测性：日志、分布式追踪、指标； 安全性：SecurityPolicy、NetworkPolicy、AuthorizationPolicy； 平台资源申请：数据库、存储等； 运行与隔离：ECS、Docker、KataContainer 等； 资源分配和调度：各种控制器； 环境隔离：Namespace、多租户、VPC、防火墙、LimitRange、Resources； 可访问性：Service、Ingress、Egress、Gateway、LoadBalancer、VirtualService、DestinationRule、ServiceEntry； 状态管理：Operator； 可观察性：日志、监控、指标； 安全性：SecurityPolicy、ServiceAccount；  云原生应用分层模型 那么究竟如何来给云原生应用分层，化繁就简？近几年来，基于 Kubernetes 的应用呈爆炸式发展，光是在应用交付领域的开源项目就达几十个之多。下图展示我根据这些项目的特性而绘制的 App Delivery Landscape。\n 应用定义和包装：云原生应用的最上层，直接定义云原生应用的组成形式，解决云原生应用之间的依赖关系，并封装成发布包，如 Helm、CNAB，还有云原生变成语言 Pulumi 和 Ballerina，基于 API 的方式来编排云原生应用； 负载定义：基于 Kubernetes Operator，大多是 Serverless 负载，既负责了负载的定义又负责了生命周期管理。Istio 是比较特殊的存在，它不仅管理服务间的流量，还负责安全性、可观察性。 应用发布和上线：关注应用的构建和发布、GitOps、发布策略等，这也是云原生应用全景中最丰富的部分之一； Kubernetes 原语：Kubernetes 本身提供的原语，Operator 基于此构建；  以上为我个人分类的云原生应用全景模型，仅限于 Kubernetes 之上的应用，对于其他非 Kubernetes 应用非本文的考虑范围。另外，CNCF SIG App Delivery 中也给出的云原生应用的分层模型，其模型将非 Kubernetes 应用场景也纳入了考虑，详见：The Dictionary of Cloud-Native App Delivery。\nPlatform/Kuberntes，Kubernetes 仅仅是屏蔽了平台的一些差异，但是对于最上层的应用来说，没有涉及，用户需要自己来基于各种开源组件来搭积木。\nOAM（开放应用模型） 那么以上这么多应用有哪些共性，能不能再进一步抽象呢？\n 所有应用是都以容器作为运行时环境（ContainerizedWorkload），这是 OAM 中的核心 Workload 类型； 在应用发布和上线方面，有些是属于应用的运维特征，需要根据实际需求组合和变更，这些是持续变动的部分； 要实现某些复杂的应用管控，需要使用到多个 CRD 的组合，比如 Istio 中的让流量根据白分比切分到不同的而服务，就需要部署 Istio Operator，并声明 VirtualService、DestinationRule，二者同时使用；  一个 ApplicationConfiguration 的 Runtime 的正常流程应该是：\n 应用开发者创建自己的 Component，在 Component 中描述要应用相关的信息，如应用名称、镜像配置、环境变量等，应用到 Kubernetes cluster 中； 运维创建各种运维策略，如发布策略、网络策略等等，发布时由 AppConfig 对象关联要发布的 Component 和本次的运维策略，apply 到集群中，集群的 OAM operator watch 到一次 ApplicationConfiguration的下发，生成 Component 对应的 Workload 和 Trait，Trait controller 将本次的 Trait 策略应用到本次要管理的 Workload 当中，最终到达终态，完成一次发布。  OAM 是对 Kubernetes 友好的，一样采用声明式 API 的理念开发。如果你已经编写了现成的 CRD Operator，可以平滑的接入到 OAM 体系中。OAM 以应用为中心，高度可扩展，扩展点包括：\n Workload：扩展各种运行时类型，不仅限于容器运行时，还可以定义更多其他运行时，比如 Serverless 负载、虚拟机、数据库、网络等；例如，Pod、无服务器函数、数据存储、消息队列或任何其他类型的工作负载，这些都是应用程序开发人员需要设计一个完整的应用程序所需要的，可以直接引用 Kubernetes 的 CRD； Trait：各种运维规则，比如扩缩容、流量控制、安全性；  生态 以前 CNCF 的主要关注群体大多是基础设施领域的技术人员，但是自 2019 年 9 月，CNCF 宣布成立 SIG App Delivery 后，CNCF 正在将应用开发者和运维人员更紧密的联系在一起。应用交付 SIG 的使命是：\n 在与开发、分发、部署、管理和运行安全的云原生应用相关的领域进行合作，目标是以云原生方式交付应用。 发展信息资源，包括指南、教程和白皮书，让社区了解最佳实践和应用交付的价值。 识别合适的项目和现状的差距，定期向 TOC 更新，并以结构化的方式向 TOC 提出行动建议。这包括帮助 TOC 评估和对潜在的新项目进行尽职调查。  目前 OAM 定义的云原生应用模型已有以下项目支持。\n Crossplane：这是一个开源的 Kubernetes 扩展组件，适用于主流公有云平台，使用 kubectl 配置和管理基础架构、服务和应用。对于 OAM 的支持详见运行应用程序。 KPT：Kpt（发音为 \u0026ldquo;keep\u0026rdquo;）是一个在资源配置之上构建声明性工作流的开源工具。它的 git + YAML 架构意味着它只需与现有的工具、框架和平台一起工作。Kpt 包括了获取、显示、自定义、更新、验证和应用 Kubernetes 配置的解决方案。对 OAM 的支持详见 使用 kpt 来管理由开放应用模型（OAM）定义的自定义 Kubernetes 应用程序。  应用交付领域相关的开源项目还有很多，详见 Awesome Cloud Native。\n总结 基于 Kubernetes 的云原生生态发展至今已有 6 年时间，当前已步入了普及推广阶段。可以说谁云原生应用定义的制高点，就可以掌握云原生的未来。从前我们是新技术浪潮的追随者，现在我们抓住时代的基于，参与标准制定、引领云原生的浪潮！欢迎加入 OAM 社区，一起参与进来，把国人参与指定的标准推向世界。\n参考  Do you know what’s in Helm 3? - developer.ibm.com O’Reilly: Kubernetes patterns for designing cloud-native apps - redhat.com The Dictionary of Cloud-Native App Delivery - docs.google.com CNCF 宣布成立应用交付领域小组，正式开启云原生应用时代 - infoq.cn OAM v1alpha2 新版发布：平衡标准与可扩展性，灵活接入 CRD operator - mp.weixin.qq.com Kubernetes API 与 Operator，不为人知的开发者战争  ","excerpt":"重点  云原生已渡过了野蛮生长期，正朝着统一应用标准方向迈进。 Kubernetes 的原语无法完整描述云原生应用体系，且在对资源的配置上开发与运维功能耦合严重。 Operator …","ref":"https://jimmysong.io/guide-to-cloud-native-app/docs/post-kubernetes-era/","title":"Kubernetes 次世代的云原生应用"},{"body":" 本文基于 OAM v1alpha2 版本。\n 应用程序可用的 Workload 类型是由平台提供商和基础设施运维人员提供的。Workload 模型参照 Kubernetes 规范定义，理论上，平台商可以定义如容器、Pod、Serverless 函数、虚拟机、数据库、消息队列等任何类型的 Workload。\n下面是一个 Workload 定义的是示例。\napiVersion:core.oam.dev/v1alpha2kind:WorkloadDefinitionmetadata:name:schema.example.jimmysong.iospec:definitionRef:name:schema.example.jimmysong.io 关于 definitionRef CR 即 Custom Resource（自定义资源），指的是实例化后的 Kubernetes CRD。应用开发者可以在 Component 的 Workload 中直接定义 CR。definitionRef 将 Workload shcema 在 OAM 解释器中注册，通过增加一个抽象层，使其与 Operator 框架解耦（毕竟不是说有 CRD 都是面向应用开发者的），表示可作为负载类型使用。  请保持 spec.definitionRef.name 的值与 metadata.name 的值相同，因为 definitionRef 是对相应的 Workload schema 的引用，对于 Kubernetes 平台来说，即对 CRD 的引用。应用开发者在定义 Component 引用该 Workload 的时候需要直接实例化一个 CRD 的配置（及创建一个 CR）。\nOAM 中将 Workload 分成了 core.oam.dev（核心）、standard.oam.dev（标准）及自定义扩展类别。目前 OAM 中支持的核心 Workload 有 ContainerizedWorkload。\n关于 Workload 的详细信息参考 OAM 中的 Workload 规范。\n","excerpt":"本文基于 OAM v1alpha2 版本。\n 应用程序可用的 Workload 类型是由平台提供商和基础设施运维人员提供的。Workload 模型参照 Kubernetes 规范定义，理论上，平台商可 …","ref":"https://jimmysong.io/guide-to-cloud-native-app/docs/spec/workload/","title":"Workload"},{"body":" 本文基于 OAM v1alpha2 版本。\n Component 用于定义应用程序的基本组件，其中包含了对 Workload 的引用，一个 Component 中只能定义一个 Workload，这个 Workload 是与平台无关的，可以直接引用 Kubernetes 中的 CRD。\n下面是根据 OAM 规范定义的一个 Component 示例。\napiVersion:core.oam.dev/v1alpha2kind:Componentmetadata:name:my-componentspec:workload:apiVersion:core.oam.dev/v1alpha2kind:ContainerizedWorkloadspec:os:linuxcontainers:-name:serverimage:my-image:latestparameters:-name:myServerImagerequired:truefieldPaths:-\u0026#34;.spec.containers[0].image\u0026#34; Component 定义由以下几个部分组成：\n metadata：关于 Component 的信息，主要是针对应用运维的信息。 workload：该 Component 的实际工作负载。具体有哪些负载类型可用可以咨询平台提供商，平台运维也可以根据 Workload 规范 来扩展负载类型，比如 Containers、Functions、VirtualMachine、VirtualService 等。OAM 目前定义的核心负载类型有 ContainerizedWorkload（与 Kubernetes 中的 Pod 定义类似，同样支持定义多个容器，但是缺少了 Pod 中的一些属性 ）。 parameters：在应用程序运行时可以调整的参数，即应用开发者在 Component 中的原有定义可以在运行时被应用运维人员覆盖。parameters 使用 JSONPath 的方式引用 spec 中的字段。  Component 是可变的 Component 的配置在应用后是可更改的（Mutable）， 有的 Trait 可能会监听 Component 的变更并作出相应的操作，每次变更都会导致新的 ApplicationConfiguration 发布。  关于 Component 的详细信息请参考 OAM 中的 Component 规范。\n","excerpt":"本文基于 OAM v1alpha2 版本。\n Component 用于定义应用程序的基本组件，其中包含了对 Workload 的引用，一个 Component 中只能定义一个 Workload， …","ref":"https://jimmysong.io/guide-to-cloud-native-app/docs/spec/component/","title":"Component"},{"body":" 云原生应用在诞生之初就是面向云而设计，适应云环境，为了在云上运行而开发的应用，既然是应用就涉及到生命周期管理，在一个云原生应用的生命周期中，存在以下几种角色，如下图所示。\n三者之间不是完全独立，而是互有交集。\n 应用开发者：关注的是代码，对应用的生命周期负责，需要了解业务逻辑。 应用运维：维护应用平台，负责管理应用的生命周期管，需要具有应用的领域知识。 基础设施运维：维护计算、存储和网络资源，需要具有底层系统的知识。  下面将分别阐述这三种角色之间的区别和联系。\n应用开发者 应用开发者负责编写代码，实现应用程序的业务逻辑和数据的处理，是应用程序的拥有者、负责人。底层的计算、存储、网络的复杂性全部通过编程语言层面给屏蔽掉了，比如开发者需要发起远程过程调用（RPC），只需要指定对应的协议，调用相应的接口，传递符合规范的数据即可，而不需要自己去实现一个协议。\n注意这里之所以在开发者前面加上了”应用“两个字，是为了强调这部分开发者是面向业务的开发者，而非基础设施、中间件或者平台开发者，虽然他们本质上都是开发者，但是面向的对象不同。应用开发者负责生产应用程序，并负责它的升级换代，但是对于应用生产出来后如何维护，就要交给应用运维了。\n应用运维 应用运维人员通常基于 PaaS 平台为应用程序提供运行时所需的资源或能力，负责管理应用程序的生命周期，更加关注应用交付，如应用的构建、打包、编排、调度、发布、升级、回滚、配置、备份等，这些操作通常与开发者要运行的应用程序的本身逻辑无关。当需要为某些类型的应用提供平台层能力的时候，应用运维还需要具有这些应用所处领域的专业知识。比如数据科学家需要使用的大数据集群，这些集群通常会有专人来维护，这些人可能不会直接参与底层基础设施的建设，而是负责在 PaaS 平台上维护这套集群。但是对于一些简单的 web 应用，应用运维的角色有时候也会由开发者兼任，也就是 DevOps。\n基础设施运维 基础设施运维可能是管理公有云中的资源（虚拟机或容器），也可能直接管理底层的物理资源，他们不必了解这些资源上具体运行的是什么应用，也不需要相关领域的背景知识，在他们眼里一切皆为资源（计算、存储、网络），他们需要负责基础设施的稳定性，资源的利用率，账号的权限管理等。\n关系 这三个角色不是孤立存在的，他们之间存在很多交集，其中应用运维是将开发者与程序运行资源、环境串联起来的关键，这个角色部分职能可以由 PaaS 平台来完成。\n","excerpt":"云原生应用在诞生之初就是面向云而设计，适应云环境，为了在云上运行而开发的应用，既然是应用就涉及到生命周期管理，在一个云原生应用的生命周期中，存在以下几种角色，如下图所示。\n三者之间不是完全独立，而是互 …","ref":"https://jimmysong.io/guide-to-cloud-native-app/docs/roles/","title":"角色与分工"},{"body":" 本文基于 OAM v1alpha2 版本。\n Trait 用于定义 Component 的运维属性，是对 Component 运行时的叠加，需要通过 ApplicationConfiguration 的配置将其与 Component 绑定，用于动态修改 Component 中 workload 的行为。\n不同的 Trait 可能适用于不同的 Component（因为不同的 Component 中的 workload 可能不同，因此它们的运维特性也可能不同），如流量路由规则（如负载均衡策略、入口路由、出口路由、百分比路由、限流、熔断、超时限制、故障注入等）、自动缩放策略、升级策略、发布策略等。\nTrait 还具有以下几个特征：\n Trait 是根据在 Component 中引用的顺序应用的，如果某些运维特征本身具有依赖性，可以通过显式排序来解决； 对于某一类型的 Trait 在同一个 Component 实例只能应用一个； 在应用 Trait 时，需要进行冲突检查，如果一组 Trait 的特性不能满足运维组合，则判定为不合法；  将运维属性从应用组件本身的定义（ Component）中剥离有如下几个好处：\n Trait 通常由应用运维人员定义和维护，而不需要应用开发人员参与，应用开发人员对 Trait 可能无感知，减轻了应用开发人员的负担； Trait 将云原生应用程序的一些通用运维属性从应用配置中剥离出来，大大提高了运维逻辑的可复用性； 应用 Trait 组合前进行运维特性检查，可以有效防止配置冲突和无法预期的情况发生；  下面是根据 OAM 规范定义的一个 Trait 示例。\napiVersion:core.oam.dev/v1alpha2kind:TraitDefinitionmetadata:name:manualscalertrait.core.oam.devspec:appliesToWorkloads:-core.oam.dev/v1alpha2.ContainerizedWorkloaddefinitionRef:name:manualscalertrait.core.oam.dev 关于 definitionRef CR 即 Custom Resource（自定义资源），指的是实例化后的 Kubernetes CRD。definitionRef 将 Trait shcema 在 OAM 解释器中注册，通过增加一个抽象层，使其与 Operator 框架解耦（毕竟不是说有 CRD 都是面向应用开发者的）。  OAM 中将 Trait 分成了 core.oam.dev（核心）、standard.oam.dev（标准）及自定义扩展类别。一个 Trait 具体适用于哪些 workload 可以在 Trait 的 TraitDefinition 中定义。目前 OAM 中支持的核心 Trait 有 ManualScalerTrait。\n关于 Trait 的详细请参考 OAM 中的 Trait 规范。\n","excerpt":"本文基于 OAM v1alpha2 版本。\n Trait 用于定义 Component 的运维属性，是对 Component 运行时的叠加，需要通过 ApplicationConfiguration  …","ref":"https://jimmysong.io/guide-to-cloud-native-app/docs/spec/trait/","title":"Trait"},{"body":" 本文参考的是 OAM 规范中对云原生应用的定义，并做出了引申。\n 云原生应用是一个相互关联但又不独立的组件（service、task、worker）的集合，这些组件与配置结合在一起并在适当的运行时实例化后，共同完成统一的功能目的。\n云原生应用模型 下图是 OAM 定义的云原生应用模型示意图，为了便于理解，图中相同颜色的部分为同一类别的对象定义。\nOAM 的规范中定义了以下对象，它们既是 OAM 规范中的基本术语也是云原生应用的基本组成。\n Workload（工作负载）：应用程序的工作负载类型，由平台提供。 Component（组件）：定义了一个 Workload 的实例，并以基础设施中立的术语声明其运维特性。 Trait（特征）：用于将运维特性分配给组件实例。 ApplicationScope（应用作用域）：用于将组件分组成具有共同特性的松散耦合的应用。 ApplicationConfiguration（应用配置）：描述 Component 的部署、Trait 和 ApplicationScope。  OAM 规范中提供了一个使用以上对象定义云原生应用的工作流示例。\n关注点分离 下图是不同角色对于该模型的关注点示意图。\n我们可以看到对于一个云原生应用来说，不同的对象是由不同的角色来负责的：\n 基础设施运维：提供不同的 Workload 类型供开发者使用； 应用运维：定义适用于不同 Workload 的运维属性 Trait 和管理 Component 的 ApplicationScope 即作用域； 应用开发者：负责应用组件 Component 的定义； 应用开发者和运维：共同将 Component 与运维属性 Trait 绑定在一起，维护应用程序的生命周期；  基于 OAM 中的对象定义的云原生应用可以充分利用平台能力自由组合，开发者和运维人员的职责可以得到有效分离，组件的复用性得到大幅提高。\n参考  The Open Application Model specification - github.com  ","excerpt":" 本文参考的是 OAM 规范中对云原生应用的定义，并做出了引申。\n 云原生应用是一个相互关联但又不独立的组件（service、task、worker）的集合，这些组件与配置结合在一起并在适当的运行时实 …","ref":"https://jimmysong.io/guide-to-cloud-native-app/docs/cloud-native-app/","title":"云原生应用的定义"},{"body":"OAM 规范的设计遵循了以下原则：\n 关注点分离：根据功能和行为来定义模型，以此划分不同角色的职责， 平台中立：OAM 的实现不绑定到特定平台； 优雅：尽量减少设计复杂性； 复用性：可移植性好，同一个应用程序可以在不同的平台上不加改动地执行； 不作为编程模型：OAM 提供的是应用程序模型，描述了应用程序的组成和组件的拓扑结构，而不关注应用程序的具体实现。  下图是 OAM 规范示意图。\n图片来自 oam/spec issue #346。\n","excerpt":"OAM 规范的设计遵循了以下原则：\n 关注点分离：根据功能和行为来定义模型，以此划分不同角色的职责， 平台中立：OAM 的实现不绑定到特定平台； 优雅：尽量减少设计复杂性； 复用性：可移植性好，同一个 …","ref":"https://jimmysong.io/guide-to-cloud-native-app/docs/spec/","title":"规范模型"},{"body":" 本文基于 OAM v1alpha2 版本。\n ApplicationScope 根据 Component 中的应用逻辑或共同行为划定作用域，将其分组以便于管理。\nApplicationScope 具有以下特征：\n 一个 Component 可能属于一个或多个 ApplicationScope； 有的 ApplicationScope 可以限定其中是否可以部署同一个 Component 的多个实例； ApplicationScope 可以作为 Component 与基础设施的连接层，提供身份、网络或安全能力； Trait 可以根据 Component 中定义的 ApplicationScope 来执行适当的运维特性；  目前 OAM 中支持的核心应用范围类型有 NetworkScope 和 HealthScope。\n下面是使用 NetworkScope 来声明作用域的示例：\napiVersion:core.oam.dev/v1alpha2kind:NetworkScopemetadata:name:my-networklabels:region:my-regionenvironment:productionspec:networkId:my-networksubnetIds:-my-subnetwork-01-my-subnetwork-02-my-subnetwork-03internetGatewayType:nat 上面的示例的作用是将三个子网划定为一组网络边界，这通常是使用 VPC 实现。\n关于 ApplicationScope 的详细信息请参考 OAM 中的 ApplicationScope 规范。\n","excerpt":"本文基于 OAM v1alpha2 版本。\n ApplicationScope 根据 Component 中的应用逻辑或共同行为划定作用域，将其分组以便于管理。\nApplicationScope 具有 …","ref":"https://jimmysong.io/guide-to-cloud-native-app/docs/spec/application-scope/","title":"ApplicationScope"},{"body":" 本文基于 OAM v1alpha2 版本。\n ApplicationConfiguration 将 Component 与 Trait 组合，定义了一个应用程序的配置，Component 每部署一次就会产生一个实例（Instance），实例是可以被升级的（包括回滚和重新部署），而每次部署和升级就会产生一次新的发布（Release）。\n关于 Release 12 因素应用严格区分构建、发布、运行这三个步骤。每次构建和修改配置后都会产生一次新的发布（Release）。OAM 中将 Component、Trait、ApplicaitonScope 组合而成的 ApplicationConfiguration 即等同于 Release。每次对 ApplciationConfiguration 的更新都会创建一个新的 Release（跟 Helm 中的 Release 概念一致）。  下面是一个 ApplicationConfiguration 示例。\napiVersion:core.oam.dev/v1alpha2kind:ApplicationConfigurationmetadata:name:my-appannotations:version:v1.0.0description:\u0026#34;My first application deployment.\u0026#34;spec:components:-componentName:my-componentparameterValues:-name:PARAMETER_NAMEvalue:SUPPLIED_VALUE-name:ANOTHER_PARAMETERvalue:\u0026#34;AnotherValue\u0026#34;traits:-name:manualscaler.core.oam.devversion:v1spec:replicaCount:3scopes:-scopeRef:apiVersion:core.oam.dev/v1alpha2kind:NetworkScopename:my-network 关于 ApplicationConfiguration 的详细信息参考 OAM 中的 ApplicationConfiguration 规范。\n","excerpt":"本文基于 OAM v1alpha2 版本。\n ApplicationConfiguration 将 Component 与 Trait 组合，定义了一个应用程序的配置，Component 每部署一次就 …","ref":"https://jimmysong.io/guide-to-cloud-native-app/docs/spec/application-configuration/","title":"ApplicationConfiguration"},{"body":"云原生应用白皮书。\n","excerpt":"云原生应用白皮书。","ref":"https://jimmysong.io/guide-to-cloud-native-app/docs/","title":"白皮书"},{"body":"","excerpt":"","ref":"https://jimmysong.io/guide-to-cloud-native-app/index.json","title":""},{"body":"  #td-cover-block-0 { background-image: url(/guide-to-cloud-native-app/featured-background_hu2a3c8bc746d550421192af01f1d0a928_54159_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/guide-to-cloud-native-app/featured-background_hu2a3c8bc746d550421192af01f1d0a928_54159_1920x1080_fill_q75_catmullrom_top.jpg); } }  定义云原生应用标准 白皮书  GitHub  带您探索后 Kubernetes 时代的云原生应用发展路径\n       ","excerpt":"  #td-cover-block-0 { background-image: …","ref":"https://jimmysong.io/guide-to-cloud-native-app/","title":"定义云原生应用标准"},{"body":"","excerpt":"","ref":"https://jimmysong.io/guide-to-cloud-native-app/search/","title":"搜索结果"}]